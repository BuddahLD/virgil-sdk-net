<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Virgil SDK: Perfect Forward Secrecy</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Virgil SDK
   &#160;<span id="projectnumber">4.3.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Perfect Forward Secrecy </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href="#head1">Set Up Server</a> | <a href="#head2">Set Up Clients</a> | <a href="#head3">Register Users</a> | <a href="#head4">Initialize PFS Chat</a> | <a href="#head5">Send &amp; Receive a Message</a></p>
<h2>Introduction</h2>
<p><a class="el" href="namespace_virgil.html">Virgil</a> Perfect Forward Secrecy (PFS) is designed to prevent a possibly compromised long-term secret key from affecting the confidentiality of past communications. In this tutorial, we will be helping two people or IoT devices to communicate with end-to-end <b>encryption</b> with PFS enabled.</p>
<p>Create a <a href="https://developer.virgilsecurity.com/account/signup">Developer account</a> and register your Application to get the possibility to use <a class="el" href="namespace_virgil.html">Virgil</a> Infrastructure.</p>
<h2><a class="anchor" id="head1"></a> Set Up Your Server</h2>
<p>Your server should be able to authorize your users, store Application's <a class="el" href="namespace_virgil.html">Virgil</a> Key and use <b><a class="el" href="namespace_virgil.html">Virgil</a> SDK</b> for cryptographic operations or for some requests to <a class="el" href="namespace_virgil.html">Virgil</a> Services. You can configure your server using the https://github.com/VirgilSecurity/virgil-sdk-net/blob/v4/documentation/guides/configuration/server.md "Setup Guide".</p>
<h2><a class="anchor" id="head2"></a> Set Up Your Clients</h2>
<p>Setup the client-side to provide your users with an access token after their registration at your Application Server to authenticate them for further operations and transmit their  to the server. Configure the client-side using the https://github.com/VirgilSecurity/virgil-sdk-net/blob/v4/documentation/guides/configuration/client-pfs.md "Setup Guide".</p>
<h2><a class="anchor" id="head3"></a> Register Users</h2>
<p>Now you need to register the users who will participate in encrypted communications.</p>
<p>In order to sign and encrypt a message each user must have his own tools, which allow him to perform cryptographic operations, and these tools must contain the necessary information to identify users. In <a class="el" href="namespace_virgil.html">Virgil</a> Security, these tools are the <a class="el" href="namespace_virgil.html">Virgil</a> Key and the <a class="el" href="namespace_virgil.html">Virgil</a> Card.</p>
<div class="image">
<img src="https://github.com/VirgilSecurity/virgil-sdk-net/blob/v4/documentation/img/Card_introduct.png"  alt="Virgil Card" title="Create Virgil Card"/>
</div>
<p>When we have already set up the <a class="el" href="namespace_virgil.html">Virgil</a> SDK on the server &amp; client sides, we can finally create <a class="el" href="namespace_virgil.html">Virgil</a> Cards for the users and transmit the Cards to your Server for further publication on <a class="el" href="namespace_virgil.html">Virgil</a> Services.</p>
<h3>Generate Keys and Create <a class="el" href="namespace_virgil.html">Virgil</a> Card</h3>
<p>Use the <a class="el" href="namespace_virgil.html">Virgil</a> SDK on the client side to generate a new Key Pair, and then create a user's <a class="el" href="namespace_virgil.html">Virgil</a> Card using the recently generated <a class="el" href="namespace_virgil.html">Virgil</a> Key. All keys are generated and stored on the client side.</p>
<p>In this example, we will pass on the user's username and a password, which will lock in their private encryption key. Each <a class="el" href="namespace_virgil.html">Virgil</a> Card is signed by a user's <a class="el" href="namespace_virgil.html">Virgil</a> Key, which guarantees the <a class="el" href="namespace_virgil.html">Virgil</a> Card's content integrity over its life cycle.</p>
<div class="fragment"><div class="line"><span class="comment">// generate a new Virgil Key</span></div><div class="line">var aliceKeys = crypto.GenerateKeys();</div><div class="line"></div><div class="line"><span class="comment">// save the Virgil Key into the storage</span></div><div class="line">var exportedPrivateKey = crypto.ExportPrivateKey(aliceKeys.PrivateKey, <span class="stringliteral">&quot;[KEY_PASSWORD]&quot;</span>);</div><div class="line">var keyEntry = <span class="keyword">new</span> KeyEntry</div><div class="line">  {</div><div class="line">    Name = <span class="stringliteral">&quot;[KEY_NAME]&quot;</span>,</div><div class="line">    Value = exportedPrivateKey</div><div class="line">  };</div><div class="line">var keyStorage = <span class="keyword">new</span> DefaultKeyStorage();</div><div class="line">keyStorage.Store(keyEntry);</div><div class="line"></div><div class="line"><span class="comment">// prepare a request</span></div><div class="line">var exportedPublicKey = crypto.ExportPublicKey(aliceKeys.PublicKey);</div><div class="line">var request = <span class="keyword">new</span> PublishCardRequest(<span class="stringliteral">&quot;alice&quot;</span>, <span class="stringliteral">&quot;member&quot;</span>, exportedPublicKey);</div><div class="line"></div><div class="line"><span class="comment">// sign the request</span></div><div class="line">var requestSigner = <span class="keyword">new</span> RequestSigner(crypto);</div><div class="line">requestSigner.SelfSign(request, keyPair.PrivateKey);</div><div class="line">requestSigner.AuthoritySign(request, <span class="stringliteral">&quot;[APP_ID]&quot;</span>, <span class="stringliteral">&quot;[APP_KEY]&quot;</span>);</div></div><!-- fragment --><p>Warning: <a class="el" href="namespace_virgil.html">Virgil</a> doesn't keep a copy of your <a class="el" href="namespace_virgil.html">Virgil</a> Key. If you lose a <a class="el" href="namespace_virgil.html">Virgil</a> Key, there is no way to recover it.</p>
<p>In order for the Sender to be able to send a message, we also need a <a class="el" href="namespace_virgil.html">Virgil</a> Card associated with the Recipient. It should be noted that recently created user <a class="el" href="namespace_virgil.html">Virgil</a> Cards will be visible only for application users because they are related to the Application.</p>
<p>Read more about <a class="el" href="namespace_virgil.html">Virgil</a> Cards and their types https://github.com/VirgilSecurity/virgil-sdk-net/blob/v4/documentation/guides/virgil-card/creating-card.md "here".</p>
<h3>Transmit the Cards to Your Server</h3>
<p>Next, you must serialize and transmit this cards to your server, where you will Approve &amp; Publish Users' Cards.</p>
<div class="fragment"><div class="line"><span class="comment">// export the request to a string</span></div><div class="line">var exportedRequest = request.Export();</div><div class="line"></div><div class="line"><span class="comment">// transmit the request to the server</span></div><div class="line">TransmitToServer(exportedRequest);</div></div><!-- fragment --><p>Use the https://github.com/VirgilSecurity/virgil-sdk-net/blob/v4/documentation/guides/configuration/server.md "approve &amp; publish users guide" to publish users <a class="el" href="namespace_virgil.html">Virgil</a> Cards on <a class="el" href="namespace_virgil.html">Virgil</a> Services.</p>
<h2><a class="anchor" id="head4"></a> Initialize PFS Chat</h2>
<p>With the user's Cards in place, we are now ready to initialize a PFS chat. In this case, we will use the Recipient's Private Keys, the <a class="el" href="namespace_virgil.html">Virgil</a> Cards and the Access Token.</p>
<p>In order to begin communicating, Bob must run the initialization:</p>
<div class="fragment"><div class="line">var secureChatPreferences = <span class="keyword">new</span> SecureChatPreferences(</div><div class="line">    <span class="stringliteral">&quot;[CRYPTO]&quot;</span>,</div><div class="line">        <span class="stringliteral">&quot;[BOB_IDENTITY_CARD]&quot;</span>,</div><div class="line">        <span class="stringliteral">&quot;[BOB_PRIVATE_KEY]&quot;</span>,</div><div class="line">        <span class="stringliteral">&quot;[YOUR_ACCESS_TOKEN_HERE]&quot;</span>);</div><div class="line"></div><div class="line">this.SecureChat = <span class="keyword">new</span> SecureChat(secureChatPreferences);</div><div class="line">    <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">        await this.SecureChat.RotateKeysAsync(100);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">catch</span>(Exception){</div><div class="line">    <span class="comment">//...</span></div><div class="line">    }</div></div><!-- fragment --><p>Warning: If Bob does not run the chat initialization, Alice cannot create an initial message.</p>
<p>Then, Alice must run the initialization:</p>
<div class="fragment"><div class="line">var secureChatPreferences = <span class="keyword">new</span> SecureChatPreferences(</div><div class="line">  <span class="stringliteral">&quot;[CRYPTO]&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;[ALICE_IDENTITY_CARD]&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;[ALICE_PRIVATE_KEY]&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;[YOUR_ACCESS_TOKEN_HERE]&quot;</span>);</div><div class="line"></div><div class="line">  this.SecureChat = <span class="keyword">new</span> SecureChat(secureChatPreferences);</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      await this.SecureChat.RotateKeysAsync(100);</div><div class="line">    }</div><div class="line"> <span class="keywordflow">catch</span> (Exception){</div><div class="line">    <span class="comment">//...</span></div><div class="line"> }</div></div><!-- fragment --><p>After chat initialization, Alice and Bob can start their PFS communication.</p>
<h2><a class="anchor" id="head5"></a> Send &amp; Receive a Message</h2>
<p>Once Recipients initialized a PFS Chat, they can communicate.</p>
<p>Alice establishes a secure PFS conversation with Bob, encrypts and sends the message to him:</p>
<div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keywordtype">void</span> SendMessage(User receiver, <span class="keywordtype">string</span> message) {</div><div class="line">    <span class="comment">// get an active session by receiver&#39;s card id</span></div><div class="line">    var session = this.Chat.ActiveSession(receiver.Card.Id);</div><div class="line">    <span class="keywordflow">if</span> (session == null)</div><div class="line">    {</div><div class="line">        <span class="comment">// start new session with recipient if session wasn&#39;t initialized yet</span></div><div class="line">        <span class="keywordflow">try</span></div><div class="line">        {</div><div class="line">            session = await this.chat.StartNewSessionWithAsync(receiver.Card);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">catch</span>{</div><div class="line">            <span class="comment">// Error handling</span></div><div class="line">        }</div><div class="line">    }</div><div class="line">    this.SendMessage(receiver, session, message);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keywordtype">void</span> SendMessage(User receiver, SecureSession session, <span class="keywordtype">string</span> message) {</div><div class="line">    <span class="keywordtype">string</span> ciphertext;</div><div class="line">    <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">        <span class="comment">// encrypt the message using previously initialized session</span></div><div class="line">        ciphertext = session.Encrypt(message);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">catch</span> (Exception) {</div><div class="line">        <span class="comment">// Error handling</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// send a cipher message to recipient using your messaging service</span></div><div class="line">    this.Messenger.SendMessage(receiver.Name, ciphertext)</div><div class="line">}</div></div><!-- fragment --><p>Then Bob decrypts the incoming message using the conversation he has just created:</p>
<div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keywordtype">void</span> MessageReceived(<span class="keywordtype">string</span> senderName, <span class="keywordtype">string</span> message) {</div><div class="line">    var sender = this.Users.Where(x =&gt; x.Name == senderName).FirstOrDefault();</div><div class="line">    <span class="keywordflow">if</span> (sender == null){</div><div class="line">       <span class="keywordflow">return</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    this.ReceiveMessage(sender, message);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keywordtype">void</span> ReceiveMessage(User sender, <span class="keywordtype">string</span> message) {</div><div class="line">    <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">        var session = this.Chat.LoadUpSession(sender.Card, message);</div><div class="line"></div><div class="line">        <span class="comment">// decrypt message using established session</span></div><div class="line">        var plaintext = session.Decrypt(message);</div><div class="line"></div><div class="line">        <span class="comment">// show a message to the user</span></div><div class="line">        Print(plaintext);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">catch</span> (Exception){</div><div class="line">        <span class="comment">// Error handling</span></div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>With the open session, which works in both directions, Alice and Bob can continue PFS encrypted communication. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
